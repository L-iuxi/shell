SIGINT 当用户键入终端中断字符（通常为 Control-C）时，终端驱动程序将发送该信号给前台进 程组。该信号的默认行为是终止进程。

 SIGIO 利用 fcntl()系统调用，即可于特定类型（诸如终端和套接字）的打开文件描述符发生 I/O 事件时产生该信号。63.3 节将就此特性做进一步说明。

//【SUSv3 列则表示 SUSv3 是否定义了该信号。 y 默认列显示了信号的默认行为。term 表示信号终止进程，core 表示进程产生核心转储 文件并退出，ignore 表示忽略该信号，stop 表示信号停止了进程，cont 表示信号恢复 了一个已停止的进程】

SIGINT   2(信号值)   终端中断(描述) ● (susv3) term（默认）

SIGIO / 29 (SA=23, MP=22) I/O 时可能产生 ● term 



**fork()**

系统调用 fork()允许一进程（父进程）创建一新进程（子进程）。具体做法是，新 的子进程几近于对父进程的翻版：子进程获得父进程的栈、数据段、堆和执行文 本段（6.3 节）的拷贝。可将此视为把父进程一分为二，术语 fork 也由此得名。

**exit()**

库函数 exit（status）终止一进程，将进程占用的所有资源（内存、文件描述符等）归 还内核，交其进行再次分配。参数 status 为一整型变量，表示进程的退出状态。父进 程可使用系统调用 wait()来获取该状态。

调用_exit()的程序总会成功终止（即，_exit()从不返回）。

！完成对其调用后将存在两个进程，且每个进程都会从 fork() 的返回处继续执行

**vfork()**的语义在于执行该调用后，系统将保证子进程先于父进程获得调度以使用 CPU。24.2 节曾经提及 fork()是无法保证这一点的，父、子进程均有可能率先获得调度。

**execve()**

y 系统调用 execve(pathname，argv，envp)加载一个新程序（路径名为 pathname，参数 列表为 argv，环境变量列表为 envp）到当前进程的内存。这将丢弃现存的程序文本段， 并为新程序重新创建栈、数据段以及堆。通常将这一动作称为执行（execing）一个新 程序。稍后会介绍构建于 execve()之上的多个库函数，每种都为编程接口提供了实用 的变体。在彼此差异无关宏旨的场合，循例会将此类函数统称为 exec()，尽管实际上 并没有以之命名的系统调用或者库函数。

**wait()**

系统调用 wait（&status）的目的有二：其一，如果子进程尚未调用 exit()终止，那么 wait() 会挂起父进程直至子进程终止；其二，子进程的终止状态通过 wait()的 status 参数返回。



